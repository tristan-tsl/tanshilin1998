# 动机

在早期阶段，我们基于 ActiveMQ 5.x（5.3 之前）构建了我们的分布式消息中间件。我们的跨国企业将其用于异步通信、搜索、社交网络活动流、数据管道，甚至在其贸易流程中。随着我们贸易业务吞吐量的增加，来自我们的消息传递集群的压力也变得紧迫。

 在本页[为什么是 ROCKETMQ？](https://rocketmq.apache.org/docs/motivation/#why-rocketmq-)[ROCKETMQ 与 ACTIVEMQ 与 KAFKA](https://rocketmq.apache.org/docs/motivation/#rocketmq-vs-activemq-vs-kafka)

# 为什么是 RocketMQ？

根据我们的研究，随着使用的队列和虚拟主题的增加，ActiveMQ IO 模块达到了瓶颈。我们尽力通过节流、断路器或降级来解决这个问题，但效果不佳。所以我们开始关注当时流行的消息解决方案Kafka。不幸的是，Kafka 无法满足我们的要求，尤其是在低延迟和高可靠性方面，请参阅[此处](https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/)了解详情。

在这种情况下，我们决定发明一种新的消息传递引擎来处理更广泛的用例，从传统的发布/订阅场景到大容量实时零损失容忍交易系统。我们相信这个解决方案是有益的，因此我们希望将其开源给社区。如今，已有 100 多家公司在其业务中使用了 RocketMQ 的开源版本。

下表展示了 RocketMQ、ActiveMQ 和 Kafka（Apache 根据[awesome-java](https://github.com/akullpp/awesome-java)最流行的消息传递解决方案）之间的比较：

# RocketMQ 与 ActiveMQ 与 Kafka

请注意本文档由 RocketMQ 团队编写。虽然理想是对技术和特性进行无私的比较，但作者的专业知识和偏见显然有利于 RocketMQ。

下表是一个方便的快速参考，可让您一目了然地发现 RocketMQ 及其最受欢迎的替代方案之间的差异。

| 消息产品 | 客户端SDK            | 协议和规范                                     | 有序消息                                   | 预定消息 | 批量消息                   | 广播消息 | 消息过滤器                          | 服务器触发重新投递 | 消息存储                                                     | 消息追溯                     | 消息优先级 | 高可用性和故障转移                                         | 消息跟踪 | 配置                                                         | 管理和操作工具                              |
| :------- | :------------------- | :--------------------------------------------- | :----------------------------------------- | :------- | :------------------------- | :------- | :---------------------------------- | :----------------- | :----------------------------------------------------------- | :--------------------------- | :--------- | :--------------------------------------------------------- | :------- | :----------------------------------------------------------- | :------------------------------------------ |
| ActiveMQ | Java、.NET、C++ 等。 | 推送模型，支持OpenWire、STOMP、AMQP、MQTT、JMS | 独占消费者或独占队列可以确保订购           | 支持的   | 不支持                     | 支持的   | 支持的                              | 不支持             | 使用 JDBC 和高性能日志支持非常快速的持久化，例如 levelDB、kahaDB | 支持的                       | 支持的     | 支持，取决于存储，如果使用 levelDB 则需要 ZooKeeper 服务器 | 不支持   | 默认配置为低级，用户需要优化配置参数                         | 支持的                                      |
| 卡夫卡   | Java、Scala 等       | 拉模式，支持TCP                                | 确保分区内的消息排序                       | 不支持   | 支持，带有异步生产者       | 不支持   | 支持，可以使用Kafka Streams过滤消息 | 不支持             | 高性能文件存储                                               | 支持的偏移指示               | 不支持     | 支持，需要 ZooKeeper 服务器                                | 不支持   | Kafka 使用键值对格式进行配置。这些值可以从文件或以编程方式提供。 | 支持，使用终端命令公开核心指标              |
| 火箭MQ   | Java、C++、Go        | 拉模型，支持TCP、JMS、OpenMessaging            | 确保消息的严格排序，并且可以优雅地横向扩展 | 支持的   | 支持，同步模式避免消息丢失 | 支持的   | 支持，基于 SQL92 的属性过滤器表达式 | 支持的             | 高性能和低延迟的文件存储                                     | 支持的时间戳和偏移量两个表示 | 不支持     | 受支持的主从模式，无需其他套件                             | 支持的   | 开箱即用，用户只需要注意几个配置                             | 支持的、丰富的 web 和终端命令来公开核心指标 |

 **更新：** 2016 年 12 月 16 日