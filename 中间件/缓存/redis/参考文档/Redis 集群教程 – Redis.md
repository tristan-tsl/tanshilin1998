# Redis集群教程

本文档是对Redis Cluster的温和介绍，没有使用难以理解的分布式系统概念。它提供了有关如何设置集群、测试和操作集群的说明，没有详细介绍[Redis 集群规范](https://redis.io/topics/cluster-spec)中涵盖的细节，而只是从用户的角度描述系统的行为方式。

然而，本教程试图从最终用户的角度以简单易懂的方式提供有关 Redis Cluster 的可用性和一致性特征的信息。

请注意，本教程需要 Redis 3.0 或更高版本。

如果您计划运行严肃的 Redis 集群部署，即使不是严格要求，也建议阅读更正式的规范。然而，从这个文档开始，玩一段时间 Redis Cluster，然后再阅读规范是一个好主意。



## Redis 集群 101

Redis Cluster 提供了一种运行 Redis 安装的方法，其中数据 **在多个 Redis 节点之间自动分片**。

Redis Cluster 还在**分区期间**提供了**一定程度的可用性**，这实际上是在某些节点出现故障或无法通信时继续操作的能力。但是，如果发生较大的故障（例如，当大多数主节点不可用时），集群将停止运行。

那么在实践中，您从 Redis Cluster 中得到了什么？

- **在多个节点之间自动拆分数据集**的能力。
- **当部分节点出现故障**或无法与集群的其余部分通信**时继续操作**的能力。



## Redis 集群 TCP 端口

每个 Redis Cluster 节点都需要打开两个 TCP 连接。用于服务客户端的普通Redis TCP端口，例如6379，加上数据端口加上10000得到的端口，所以在示例中为16379。

第二个*高*端口用于集群总线，即使用二进制协议的节点到节点通信通道。节点使用集群总线进行故障检测、配置更新、故障转移授权等。客户端永远不要尝试与集群总线端口通信，而应始终与普通 Redis 命令端口通信，但请确保在防火墙中打开这两个端口，否则 Redis 集群节点将无法通信。

命令端口和集群总线端口偏移量是固定的，始终为 10000。

请注意，要使 Redis 集群正常工作，您需要为每个节点：

1. 用于与客户端通信的普通客户端通信端口（通常为 6379）对需要访问集群的所有客户端以及所有其他集群节点（使用客户端端口进行密钥迁移）开放。
2. 集群总线端口（客户端端口 + 10000）必须可从所有其他集群节点访问。

如果您不同时打开两个 TCP 端口，您的集群将无法按预期工作。

集群总线使用不同的二进制协议，用于节点到节点的数据交换，更适合使用很少的带宽和处理时间在节点之间交换信息。



## Redis 集群和 Docker

目前 Redis Cluster 不支持 NATted 环境，也不支持 IP 地址或 TCP 端口重新映射的一般环境。

Docker 使用一种称为*端口映射*的技术：与程序认为正在使用的端口相比，在 Docker 容器内运行的程序可能会使用不同的端口公开。这对于在同一服务器中同时使用相同端口运行多个容器非常有用。

为了使 Docker 兼容 Redis Cluster，需要使用Docker的**主机组网方式**。请检查[Docker 文档中](https://docs.docker.com/engine/userguide/networking/dockernetworks/)的`--net=host`选项以获取更多信息。



## Redis Cluster 数据分片

Redis Cluster 不使用一致散列，而是一种不同形式的分片，其中每个键在概念上都是我们所谓的**散列槽的一部分**。

Redis 集群中有 16384 个哈希槽，要计算给定键的哈希槽是多少，我们只需取密钥的 CRC16 模数 16384。

Redis 集群中的每个节点都负责哈希槽的一个子集，例如，您可能有一个包含 3 个节点的集群，其中：

- 节点 A 包含从 0 到 5500 的哈希槽。
- 节点 B 包含从 5501 到 11000 的哈希槽。
- 节点 C 包含从 11001 到 16383 的哈希槽。

这允许在集群中轻松添加和删除节点。例如，如果我想添加一个新节点 D，我需要将一些哈希槽从节点 A、B、C 移动到 D。同样，如果我想从集群中删除节点 A，我可以移动 A 提供的哈希槽到 B 和 C。当节点 A 为空时，我可以将其从集群中完全删除。

由于将哈希槽从一个节点移动到另一个节点不需要停止操作，因此添加和删除节点或更改节点持有的哈希槽百分比不需要任何停机时间。

Redis Cluster 支持多键操作，只要涉及到单个命令执行（或整个事务，或 Lua 脚本执行）的所有键都属于同一个哈希槽。用户可以使用称为*散列标签*的概念强制多个键成为同一个散列槽的一部分。

散列标签记录在 Redis 集群规范中，但要点是，如果键中的 {} 括号之间有一个子字符串，则只有字符串内的内容会被散列，例如`this{foo}key`和`another{foo}key` 保证在同一个散列槽中, 并且可以在具有多个键作为参数的命令中一起使用。



## Redis Cluster 主副本模型

为了在主节点子集出现故障或无法与大多数节点通信时保持可用，Redis 集群使用主副本模型，其中每个哈希槽具有从 1（主节点本身）到 N 个副本（N -1 个额外的副本节点）。

在我们包含节点 A、B、C 的示例集群中，如果节点 B 发生故障，集群将无法继续，因为我们不再有办法为 5501-11000 范围内的哈希槽提供服务。

然而，当集群创建时（或稍后），我们为每个主节点添加一个副本节点，这样最终的集群由主节点 A、B、C 和副本节点 A1、B1、C1 组成. 这样，如果节点 B 出现故障，系统就能够继续运行。

节点 B1 复制 B，并且 B 失败，集群会将节点 B1 提升为新的 master 并继续正常运行。

但是需要注意的是，如果节点 B 和 B1 同时发生故障，Redis Cluster 将无法继续运行。



## Redis 集群一致性保证

Redis Cluster 无法保证**强一致性**。实际上，这意味着在某些情况下，Redis Cluster 可能会丢失系统已向客户端确认的写入。

Redis Cluster 会丢失写入的第一个原因是因为它使用异步复制。这意味着在写入期间会发生以下情况：

- 您的客户端写入主 B。
- 主 B 向您的客户端回复 OK。
- 主 B 将写入传播到其副本 B1、B2 和 B3。

如您所见，B 在回复客户端之前不会等待来自 B1、B2、B3 的确认，因为这对 Redis 来说是一个令人望而却步的延迟惩罚，因此如果您的客户端写入某些内容，B 会确认写入，但会在此之前崩溃能够将写入发送到其副本，其中一个副本（未收到写入）可以提升为主，永远失去写入。

这与大多数配置为每秒将数据刷新到磁盘的数据库的**情况非常相似**，因此您已经能够推理出这种情况，因为过去使用不涉及分布式系统的传统数据库系统的经验。同样，您可以通过强制数据库在回复客户端之前将数据刷新到磁盘来提高一致性，但这通常会导致性能低得令人望而却步。在 Redis Cluster 的情况下，这相当于同步复制。

基本上，需要在性能和一致性之间进行权衡。

Redis 集群在绝对需要时支持同步写入，通过[WAIT](https://redis.io/commands/wait)命令实现。这使得丢失写入的可能性大大降低。但是，请注意，即使使用同步复制，Redis Cluster 也没有实现强一致性：在更复杂的故障场景下，始终有可能将无法接收写入的副本选为 master。

还有一个值得注意的场景是 Redis 集群将丢失写入，这种情况发生在网络分区期间，客户端与少数实例（至少包括一个主实例）隔离。

以我们的 6 个节点集群为例，由 A、B、C、A1、B1、C1 组成，有 3 个主节点和 3 个副本节点。还有一个客户端，我们将其称为 Z1。

分区发生后，可能在分区的一侧有 A、C、A1、B1、C1，而在另一侧有 B 和 Z1。

Z1 仍然能够写入 B，B 将接受其写入。如果分区在很短的时间内恢复，集群将继续正常运行。但是，如果分区持续足够的时间让 B1 在分区的多数侧提升为 master，则 Z1 同时发送给 B 的写入将丢失。

请注意，Z1 能够发送到 B 的写入量有一个**最大窗口**：如果分区的多数方已经有足够的时间来选举一个副本作为主节点，那么少数方的每个主节点都将停止接受写入。

这个时间量是 Redis Cluster 的一个非常重要的配置指令，称为**节点超时**。

节点超时后，主节点被视为发生故障，并且可以由其副本之一替换。类似地，在节点超时后，主节点无法感知大多数其他主节点，它会进入错误状态并停止接受写入。



# Redis集群配置参数

我们即将创建一个示例集群部署。在继续之前，我们先介绍一下Redis Cluster在`redis.conf`文件中引入的配置参数。有些会很明显，有些会随着您继续阅读而更加清晰。

- **cluster-enabled`<yes/no>`**：如果是，则在特定 Redis 实例中启用 Redis Cluster 支持。否则，该实例像往常一样作为独立实例启动。
- **cluster-config-file`<filename>`**：注意，尽管这个选项的名称，这不是一个用户可编辑的配置文件，而是一个Redis Cluster节点在每次有变化时自动持久化集群配置（状态，基本上）的文件，以便能够在启动时重新读取它。该文件列出了集群中的其他节点、它们的状态、持久变量等内容。由于某些消息接收，此文件通常会被重写并刷新到磁盘上。
- **cluster-node-timeout`<milliseconds>`**：Redis 集群节点不可用的最长时间，而不被视为失败。如果主节点在指定的时间内无法访问，它将由其副本进行故障转移。该参数控制Redis Cluster中的其他重要事项。值得注意的是，在指定的时间内无法访问大多数主节点的每个节点都将停止接受查询。
- **cluster-slave-validity-factor`<factor>`**：如果设置为零，副本将始终认为自己有效，因此将始终尝试对主服务器进行故障转移，无论主服务器和副本之间的链接保持断开连接的时间长短。如果值为正，则计算最大断开时间为*节点超时*值乘以此选项提供的因子，如果节点是副本，并且主链接断开的时间超过指定的时间，则不会尝试启动故障转移。例如，如果节点超时设置为 5 秒且有效性因子设置为 10，则与主服务器断开连接超过 50 秒的副本将不会尝试对其主服务器进行故障转移。请注意，如果没有能够对其进行故障转移的副本，则任何非零值都可能导致 Redis 集群在主节点故障后不可用。在这种情况下，只有当原始主节点重新加入集群时，集群才会恢复可用。
- **cluster-migration-barrier`<count>`**：一个主节点将保持连接的最小副本数，以便另一个副本迁移到不再被任何副本覆盖的主节点。有关更多信息，请参阅本教程中有关副本迁移的相应部分。
- **cluster-require-full-coverage`<yes/no>`**：如果将其设置为 yes，默认情况下，如果任何节点未覆盖一定百分比的密钥空间，则集群将停止接受写入。如果该选项设置为 no，即使只能处理有关密钥子集的请求，集群仍将提供查询服务。
- **cluster-allow-reads-when-down`<yes/no>`**：如果设置为 no，默认情况下，当集群被标记为失败时，Redis 集群中的节点将停止服务所有流量，或者当节点无法访问时达到法定人数或未达到完全覆盖时。这可以防止从不知道集群中的变化的节点读取可能不一致的数据。可以将此选项设置为 yes 以允许在失败状态期间从节点读取，这对于希望优先考虑读取可用性但仍希望防止不一致写入的应用程序非常有用。它也可以用于使用只有一个或两个分片的 Redis Cluster 时，因为它允许节点在主节点发生故障但无法自动故障转移时继续提供写入服务。



# 创建和使用 Redis 集群

注意：要手动部署 Redis 集群**，了解**它的某些操作方面**非常重要**。但是，如果您想尽快（尽快）启动并运行集群，请跳过本节和下一节，直接转到**使用 create-cluster 脚本创建 Redis 集群**。

要创建集群，我们首先需要有几个以**集群模式**运行的空 Redis 实例。这基本上意味着集群不是使用普通 Redis 实例创建的，因为需要配置特殊模式，以便 Redis 实例启用集群特定的功能和命令。

以下是一个最小的Redis集群配置文件：

```
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

如您所见，启用集群模式的只是`cluster-enabled` 指令。每个实例还包含存储此节点配置的文件的路径，默认情况下为`nodes.conf`. 这个文件永远不会被人类触及；它只是在 Redis 集群实例启动时生成，并在每次需要时更新。

请注意，按预期工作的**最小集群**需要包含至少三个主节点。对于您的第一次测试，强烈建议启动一个包含三个主节点和三个副本的六节点集群。

为此，请输入一个新目录，并创建以下以我们将在任何给定目录中运行的实例的端口号命名的目录。

就像是：

```
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
```

`redis.conf`在每个目录中创建一个文件，从 7000 到 7005。作为配置文件的模板，只需使用上面的小示例，但请确保`7000`根据目录名称将端口号替换为正确的端口号。

现在将你的 redis-server 可执行文件，**从 GitHub 不稳定分支中的最新源编译，**复制到`cluster-test`目录中，最后在你最喜欢的终端应用程序中打开 6 个终端选项卡。

像这样启动每个实例，每个选项卡一个：

```
cd 7000
../redis-server ./redis.conf
```

从每个实例的日志中可以看出，由于没有`nodes.conf`文件存在，每个节点都会为自己分配一个新的 ID。

```
[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1
```

此 ID 将永远被此特定实例使用，以便实例在集群上下文中具有唯一名称。每个节点都会记住使用此 ID 的每个其他节点，而不是通过 IP 或端口。IP 地址和端口可能会改变，但唯一的节点标识符在节点的整个生命周期中永远不会改变。我们将此标识符简称为**Node ID**。



## 创建集群

现在我们有许多实例在运行，我们需要通过向节点写入一些有意义的配置来创建我们的集群。

如果您使用 Redis 5 或更高版本，这很容易实现，因为我们在 Redis Cluster 命令行实用程序的帮助下嵌入到 中`redis-cli`，可用于创建新集群、检查或重新分片现有集群等。

对于 Redis 版本 3 或 4，有一个`redis-trib.rb`非常相似的旧工具。您可以`src`在Redis源代码分发目录中找到它。您需要安装`redis`gem 才能运行`redis-trib`.

```
gem install redis
```

第一个示例，即集群创建，将`redis-cli`在 Redis 5 以及`redis-trib`Redis 3 和 4 中使用。但是接下来的所有示例都将只使用`redis-cli`，因为如您所见，语法非常相似，您可以轻松地通过使用`redis-trib.rb help`获取有关旧语法的信息，将一个命令行更改为另一个命令行。**重要提示：**请注意，`redis-cli`如果您愿意，您可以毫无问题地将 Redis 5用于 Redis 4 集群。

要为 Redis 5 创建集群，`redis-cli`只需键入：

```
redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
--cluster-replicas 1
```

使用`redis-trib.rb`用于Redis的4或3型：

```
./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 \
127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
```

这里使用的命令是**create**，因为我们要创建一个新集群。该选项`--cluster-replicas 1`意味着我们希望为每个创建的主节点创建一个副本。其他参数是我想用来创建新集群的实例的地址列表。

显然，符合我们要求的唯一设置是创建一个具有 3 个主服务器和 3 个副本的集群。

Redis-cli 会为你推荐一个配置。通过键入**yes**接受建议的配置。集群将被配置和*加入*，这意味着实例将被引导到彼此交谈。最后，如果一切顺利，你会看到这样的消息：

```
[OK] All 16384 slots covered
```

这意味着至少有一个主实例为 16384 个可用插槽中的每一个提供服务。



## 使用 create-cluster 脚本创建 Redis 集群

如果您不想通过如上所述手动配置和执行单个实例来创建 Redis 集群，则有一个更简单的系统（但您不会了解相同数量的操作细节）。

只需检查`utils/create-cluster`Redis 发行版中的目录即可。有一个名为`create-cluster`inside的脚本（与包含它的目录同名），它是一个简单的 bash 脚本。要启动具有 3 个主节点和 3 个副本的 6 节点集群，只需键入以下命令：

1. `create-cluster start`
2. `create-cluster create`

`yes`当`redis-cli`实用程序希望您接受集群布局时，请在步骤 2 中回复。

您现在可以与集群交互，默认情况下第一个节点将从端口 30001 启动。完成后，使用以下命令停止集群：

1. `create-cluster stop`.

请阅读`README`此目录中的内容以获取有关如何运行脚本的更多信息。



## 玩集群

在这个阶段，Redis Cluster 的问题之一是缺乏客户端库实现。

我知道以下实现：

- [redis-rb-cluster](http://github.com/antirez/redis-rb-cluster)是我 (@antirez) 编写的一个 Ruby 实现，作为其他语言的参考。它是原始 redis-rb 的简单包装器，实现了与集群有效对话的最小语义。
- [redis-py-cluster](https://github.com/Grokzen/redis-py-cluster) redis-rb-cluster 到 Python 的端口。支持大多数*redis-py*功能。正在积极开发中。
- 流行的[Predis](https://github.com/nrk/predis)支持 Redis Cluster，该支持最近更新并正在积极开发中。
- 最常用的Java客户端，[Jedis](https://github.com/xetorthio/jedis)最近增加了对Redis Cluster的支持，详见项目README中的*Jedis Cluster*部分。
- [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis)提供对 C# 的支持（并且应该适用于大多数 .NET 语言；VB、F# 等）
- [thunk-redis](https://github.com/thunks/thunk-redis)提供对 Node.js 和 io.js 的支持，它是一个带有流水线和集群的基于 thunk/promise 的 redis 客户端。
- [redis-go-cluster](https://github.com/chasex/redis-go-cluster)是 Go 语言的 Redis Cluster 实现，使用[Redigo 库客户端](https://github.com/garyburd/redigo)作为基本客户端。通过结果聚合实现 MGET/MSET。
- [ioredis](https://github.com/luin/ioredis)是一个流行的 Node.js 客户端，为 Redis Cluster 提供了强大的支持。
- 该`redis-cli`实用程序在与`-c`交换机一起启动时实现了基本的集群支持。

测试 Redis 集群的一种简单方法是尝试上述任何客户端或简单的`redis-cli`命令行实用程序。以下是使用后者的交互示例：

```
$ redis-cli -c -p 7000
redis 127.0.0.1:7000> set foo bar
-> Redirected to slot [12182] located at 127.0.0.1:7002
OK
redis 127.0.0.1:7002> set hello world
-> Redirected to slot [866] located at 127.0.0.1:7000
OK
redis 127.0.0.1:7000> get foo
-> Redirected to slot [12182] located at 127.0.0.1:7002
"bar"
redis 127.0.0.1:7002> get hello
-> Redirected to slot [866] located at 127.0.0.1:7000
"world"
```

**注意：**如果您使用脚本创建集群，您的节点可能会侦听不同的端口，默认情况下从 30001 开始。

redis-cli 集群支持非常基础，因此它始终使用Redis 集群节点能够将客户端重定向到正确节点的事实。一个认真的客户端能够做得比这更好，并缓存哈希槽和节点地址之间的映射，以直接使用正确的连接到正确的节点。仅当集群配置中的某些内容发生更改时才会刷新地图，例如在故障转移之后或在系统管理员通过添加或删除节点更改集群布局之后。



## 使用 redis-rb-cluster 编写示例应用程序

在继续展示如何操作 Redis 集群、执行故障转移或重新分片之类的操作之前，我们需要创建一些示例应用程序或至少能够理解简单 Redis 集群客户端交互的语义。

通过这种方式，我们可以运行一个示例，同时尝试使节点失败，或开始重新分片，以查看 Redis Cluster 在现实条件下的行为。在没有人写入集群时查看发生的情况并不是很有帮助。

本节解释了[redis-rb-cluster 的](https://github.com/antirez/redis-rb-cluster)一些基本用法， 展示了两个示例。第一个如下，是 [`example.rb`](https://github.com/antirez/redis-rb-cluster/blob/master/example.rb) redis-rb-cluster分布里面的文件：

```
   1  require './cluster'
   2
   3  if ARGV.length != 2
   4      startup_nodes = [
   5          {:host => "127.0.0.1", :port => 7000},
   6          {:host => "127.0.0.1", :port => 7001}
   7      ]
   8  else
   9      startup_nodes = [
  10          {:host => ARGV[0], :port => ARGV[1].to_i}
  11      ]
  12  end
  13
  14  rc = RedisCluster.new(startup_nodes,32,:timeout => 0.1)
  15
  16  last = false
  17
  18  while not last
  19      begin
  20          last = rc.get("__last__")
  21          last = 0 if !last
  22      rescue => e
  23          puts "error #{e.to_s}"
  24          sleep 1
  25      end
  26  end
  27
  28  ((last.to_i+1)..1000000000).each{|x|
  29      begin
  30          rc.set("foo#{x}",x)
  31          puts rc.get("foo#{x}")
  32          rc.set("__last__",x)
  33      rescue => e
  34          puts "error #{e.to_s}"
  35      end
  36      sleep 0.1
  37  }
```

该应用程序做了一件非常简单的事情，它将表单中的键设置`foo<number>`为`number`，一个接一个。因此，如果您运行该程序，结果是以下命令流：

- 设置 foo0 0
- 设置 foo1 1
- 设置 foo2 2
- 等等……

该程序看起来比通常更复杂，因为它被设计为在屏幕上显示错误而不是以异常退出，因此对集群执行的每个操作都由`begin` `rescue`块包装。

第**14**行是程序中第一个有趣的行。它创建 Redis Cluster 对象，使用*启动节点*列表作为参数，该对象允许针对不同节点进行的最大连接数，最后是给定操作后的超时被认为是失败的。

启动节点不需要是集群的所有节点。重要的是至少有一个节点是可达的。另请注意，redis-rb-cluster 会在能够与第一个节点连接后立即更新此启动节点列表。对于任何其他认真的客户，您都应该期待这种行为。

既然我们已经将 Redis Cluster 对象实例存储在**rc**变量中，我们就可以像使用普通 Redis 对象实例一样使用该对象了。

这正是**第 18 行到第 26 行**发生的情况：当我们重新启动示例时，我们不想再次开始`foo0`，因此我们将计数器存储在 Redis 本身中。上面的代码旨在读取此计数器，或者如果计数器不存在，则为其分配零值。

但是请注意它是一个 while 循环，因为即使集群关闭并返回错误，我们也想一次又一次地尝试。正常的应用程序不需要那么小心。

**28 到 37 行**开始主循环，其中设置键或显示错误。

注意`sleep`循环结束时的调用。在您的测试中，如果您想尽快写入集群，您可以删除睡眠（相对于这是一个繁忙的循环，当然没有真正的并行性，因此您通常会在最好的条件）。

通常会减慢写入速度，以便示例应用程序更容易被人类理解。

启动应用程序会产生以下输出：

```
ruby ./example.rb
1
2
3
4
5
6
7
8
9
^C (I stopped the program here)
```

这不是一个非常有趣的程序，我们稍后会使用更好的程序，但我们已经可以看到程序运行时重新分片期间发生的情况。



## 重新分片集群

现在我们准备尝试集群重新分片。为此，请保持 example.rb 程序运行，以便您可以查看是否对程序运行产生了一些影响。此外，您可能希望对`sleep` 调用进行注释，以便在重新分片期间有一些更严重的写入负载。

重新分片基本上意味着将哈希槽从一组节点移动到另一组节点，就像集群创建一样，它是使用 redis-cli 实用程序完成的。

要开始重新分片，只需键入：

```
redis-cli --cluster reshard 127.0.0.1:7000
```

您只需要指定一个节点，redis-cli 会自动查找其他节点。

目前 redis-cli 只能在管理员支持下重新分片，你不能只是说将 5% 的插槽从这个节点移动到另一个节点（但这实现起来非常简单）。所以它从问题开始。首先是你想要做多少大的重新分片：

```
How many slots do you want to move (from 1 to 16384)?
```

我们可以尝试重新分片 1000 个哈希槽，如果示例在没有 sleep 调用的情况下仍在运行，那么这些槽应该已经包含了大量的键。

然后redis-cli需要知道重分片的目标是什么，也就是会收到hash slot的节点。我将使用第一个主节点，即 127.0.0.1:7000，但我需要指定实例的节点 ID。这已经由 redis-cli 打印在列表中，但是如果需要，我总是可以使用以下命令找到节点的 ID：

```
$ redis-cli -p 7000 cluster nodes | grep myself
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5460
```

好的，所以我的目标节点是 97a3a64667477371c4479320d683e4c8db5858b1。

现在，系统会询问您要从哪些节点获取这些密钥。我只会输入`all`以便从所有其他主节点中获取一些哈希槽。

在最终确认之后，您将看到 redis-cli 将从一个节点移动到另一个节点的每个插槽的消息，并且将为从一侧移动到另一侧的每个实际键打印一个点。

在重新分片过程中，您应该能够看到示例程序未受影响地运行。如果需要，您可以在重新分片期间多次停止并重新启动它。

在重新分片结束时，您可以使用以下命令测试集群的健康状况：

```
redis-cli --cluster check 127.0.0.1:7000
```

所有的槽都将像往常一样被覆盖，但这次 127.0.0.1:7000 的主节点将有更多的哈希槽，大约在 6461 左右。



## 编写重新分片操作的脚本

重新分片可以自动执行，无需手动以交互方式输入参数。这可以使用如下命令行实现：

```
redis-cli --cluster reshard <host>:<port> --cluster-from <node-id> --cluster-to <node-id> --cluster-slots <number of slots> --cluster-yes
```

如果您可能经常重新分片，这允许建立一些自动化，但是目前没有办法`redis-cli`自动重新平衡集群，检查密钥在集群节点之间的分布并根据需要智能地移动插槽。将来会添加此功能。

该`--cluster-yes`选项指示集群管理器自动对命令的提示回答“是”，允许它以非交互模式运行。请注意，也可以通过设置`REDISCLI_CLUSTER_YES`环境变量来激活此选项 。



## 一个更有趣的示例应用程序

我们早期编写的示例应用程序不是很好。它以一种简单的方式写入集群，甚至无需检查写入的内容是否正确。

从我们的观点来看，集群接收写入可能只是总是写的关键`foo`，以`42`每一个动作，我们不会在所有通知。

所以在`redis-rb-cluster`存储库中，有一个更有趣的应用程序，称为`consistency-test.rb`. 它使用一组计数器，默认为 1000，并发送[INCR](https://redis.io/commands/incr)命令以增加计数器。

然而，该应用程序不仅仅编写，还做了两件事：

- 当使用[INCR](https://redis.io/commands/incr)更新计数器时，应用程序会记住写入。
- 它还在每次写入之前读取一个随机计数器，并检查该值是否符合我们的预期，并将其与内存中的值进行比较。

这意味着这个应用程序是一个简单的**一致性检查器**，并且能够告诉你集群是否丢失了一些写入，或者它是否接受了我们没有收到确认的写入。在第一种情况下，我们会看到一个计数器的值小于我们记忆中的值，而在第二种情况下，该值会更大。

运行一致性测试应用程序每秒产生一行输出：

```
$ ruby consistency-test.rb
925 R (0 err) | 925 W (0 err) |
5030 R (0 err) | 5030 W (0 err) |
9261 R (0 err) | 9261 W (0 err) |
13517 R (0 err) | 13517 W (0 err) |
17780 R (0 err) | 17780 W (0 err) |
22025 R (0 err) | 22025 W (0 err) |
25818 R (0 err) | 25818 W (0 err) |
```

行节目的数量**- [R** EADS和**w ^**进行仪式，和错误的数量（查询不被接受，因为错误的，因为系统是不可用）。

如果发现不一致，则会在输出中添加新行。例如，如果我在程序运行时手动重置计数器，就会发生这种情况：

```
$ redis-cli -h 127.0.0.1 -p 7000 set key_217 0
OK

(in the other tab I see...)

94774 R (0 err) | 94774 W (0 err) |
98821 R (0 err) | 98821 W (0 err) |
102886 R (0 err) | 102886 W (0 err) | 114 lost |
107046 R (0 err) | 107046 W (0 err) | 114 lost |
```

当我将计数器设置为 0 时，实际值为 114，因此程序报告了 114 个丢失的写入（集群不记得的[INCR](https://redis.io/commands/incr)命令）。

这个程序作为测试用例更有趣，所以我们将用它来测试 Redis 集群故障转移。



## 测试故障转移

注意：在此测试期间，您应该在运行一致性测试应用程序的情况下打开一个选项卡。

为了触发故障转移，我们可以做的最简单的事情（这也是分布式系统中可能发生的语义上最简单的故障）是使单个进程崩溃，在我们的例子中是单个主进程。

我们可以使用以下命令识别主节点并使其崩溃：

```
$ redis-cli -p 7000 cluster nodes | grep master
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385482984082 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 master - 0 1385482983582 0 connected 11423-16383
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
```

好的，所以 7000、7001 和 7002 是大师。让我们使用**DEBUG SEGFAULT**命令使节点 7002 崩溃 ：

```
$ redis-cli -p 7002 debug segfault
Error: Server closed the connection
```

现在我们可以查看一致性测试的输出，看看它报告了什么。

```
18849 R (0 err) | 18849 W (0 err) |
23151 R (0 err) | 23151 W (0 err) |
27302 R (0 err) | 27302 W (0 err) |

... many error warnings here ...

29659 R (578 err) | 29660 W (577 err) |
33749 R (578 err) | 33750 W (577 err) |
37918 R (578 err) | 37919 W (577 err) |
42077 R (578 err) | 42078 W (577 err) |
```

正如您在故障转移期间所看到的，系统无法接受 578 次读取和 577 次写入，但是在数据库中没有产生不一致。这听起来可能出乎意料，因为在本教程的第一部分我们说过 Redis 集群在故障转移期间可能会丢失写入，因为它使用异步复制。我们没有说的是，这不太可能发生，因为 Redis 将回复发送到客户端，以及复制到副本的命令，大约在同一时间，因此丢失数据的窗口很小。但是很难触发并不代表不可能，所以这并没有改变Redis集群提供的一致性保证。

我们现在可以检查故障转移后的集群设置是什么（注意，在此期间我重新启动了崩溃的实例，以便它作为副本重新加入集群）：

```
$ redis-cli -p 7000 cluster nodes
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385503418521 0 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385503419023 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 :0 myself,master - 0 0 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385503419023 3 connected 11423-16383
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385503417005 0 connected 5960-10921
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385503418016 3 connected
```

现在masters运行在7000、7001和7005端口。以前的master，也就是运行在7002端口的Redis实例，现在是7005的副本。

[CLUSTER NODES](https://redis.io/commands/cluster-nodes)命令的输出可能看起来很吓人，但它实际上非常简单，由以下标记组成：

- 节点 ID
- ip:端口
- 标志：主、副本、我自己、失败、...
- 如果是副本，则是主节点的节点 ID
- 上次等待 PING 的时间仍在等待回复。
- 最后收到 PONG 的时间。
- 此节点的配置纪元（请参阅集群规范）。
- 到此节点的链接的状态。
- 插槽服务...



## 手动故障转移

有时，在不实际导致主服务器上出现任何问题的情况下强制进行故障转移很有用。例如，为了升级其中一个主节点的 Redis 进程，最好对其进行故障转移，以便将其转换为对可用性影响最小的副本。

Redis Cluster 使用[CLUSTER FAILOVER](https://redis.io/commands/cluster-failover) 命令支持手动故障转移，该命令必须在要进行故障转移的主服务器的**副本**之一中执行。

手动故障转移是特殊的，与由实际主故障引起的故障转移相比更安全，因为它们的发生方式避免了过程中的数据丢失，只有当系统确定新的主服务器时，才将客户端从原始主服务器切换到新主服务器master 处理了旧的所有复制流。

这是您在执行手动故障转移时在副本日志中看到的内容：

```
# Manual failover user request accepted.
# Received replication offset for paused master manual failover: 347540
# All master replication stream processed, manual failover can start.
# Start of election delayed for 0 milliseconds (rank #0, offset 347540).
# Starting a failover election for epoch 7545.
# Failover election won: I'm the new master.
```

基本上连接到我们正在故障转移的主服务器的客户端被停止。同时，master 将其复制偏移量发送到副本，副本等待到达其一侧的偏移量。当达到复制偏移量时，故障转移开始，并通知旧主服务器配置切换。当客户端在旧主服务器上解除阻塞时，它们将被重定向到新主服务器。

笔记：

- 要将副本提升为 master，它必须首先被集群中的大多数 master 称为副本。否则，它无法赢得故障转移选举。如果副本刚刚添加到集群中（请参阅下面的[添加新节点作为副本](https://redis.io/topics/cluster-tutorial#adding-a-new-node-as-a-replica)），您可能需要等待一段时间才能发送[CLUSTER FAILOVER](https://redis.io/commands/cluster-failover)命令，以确保集群中的主[节点](https://redis.io/topics/cluster-tutorial#adding-a-new-node-as-a-replica)知道新副本。



## 添加新节点

添加新节点基本上是添加一个空节点然后将一些数据移动到其中的过程，如果它是新的主节点，或者告诉它设置为已知节点的副本，以防它是副本。

我们将展示两者，首先添加一个新的主实例。

在这两种情况下，执行的第一步都是**添加一个空节点**。

这就像在端口 7006 中启动一个新节点一样简单（我们已经将 7000 到 7005 用于我们现有的 6 个节点），其他节点使用相同的配置，除了端口号，所以你应该做什么为了符合我们用于之前节点的设置：

- 在终端应用程序中创建一个新选项卡。
- 进入`cluster-test`目录。
- 创建一个名为`7006`.
- 在里面创建一个 redis.conf 文件，类似于用于其他节点的文件，但使用 7006 作为端口号。
- 最后启动服务器 `../redis-server ./redis.conf`

此时服务器应该正在运行。

现在我们可以像往常一样使用**redis-cli**将节点添加到现有集群中。

```
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000
```

如您所见，我使用**add-node**命令将新节点的地址指定为第一个参数，并将集群中随机现有节点的地址指定为第二个参数。

实际上，redis-cli 在这里对我们帮助很小，它只是向节点发送了一个[CLUSTER MEET](https://redis.io/commands/cluster-meet)消息，这也可以手动完成。然而，redis-cli 在操作之前也会检查集群的状态，因此即使您知道内部工作原理，也始终通过 redis-cli 执行集群操作是个好主意。

现在我们可以连接到新节点，看看它是否真的加入了集群：

```
redis 127.0.0.1:7006> cluster nodes
3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 127.0.0.1:7001 master - 0 1385543178575 0 connected 5960-10921
3fc783611028b1707fd65345e763befb36454d73 127.0.0.1:7004 slave 3e3a6cb0d9a9a87168e266b0a0b24026c0aae3f0 0 1385543179583 0 connected
f093c80dde814da99c5cf72a7dd01590792b783b :0 myself,master - 0 0 0 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543178072 3 connected
a211e242fc6b22a9427fed61285e85892fa04e08 127.0.0.1:7003 slave 97a3a64667477371c4479320d683e4c8db5858b1 0 1385543178575 0 connected
97a3a64667477371c4479320d683e4c8db5858b1 127.0.0.1:7000 master - 0 1385543179080 0 connected 0-5959 10922-11422
3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 127.0.0.1:7005 master - 0 1385543177568 3 connected 11423-16383
```

请注意，由于此节点已连接到集群，因此它已经能够正确重定向客户端查询，并且通常是集群的一部分。然而，与其他大师相比，它有两个特点：

- 它没有数据，因为它没有分配的哈希槽。
- 因为它是一个没有分配slots的master，所以当一个replica想成为master时，它不参与选举过程。

现在可以使用 的重新分片功能为该节点分配哈希槽`redis-cli`。像我们在上一节中所做的那样显示这一点基本上没有用，没有区别，只是以空节点为目标的重新分片。



## 添加新节点作为副本

添加新副本可以通过两种方式执行。显而易见的是再次使用 redis-cli，但使用 --cluster-slave 选项，如下所示：

```
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave
```

请注意，这里的命令行与我们用来添加新主服务器的命令行完全相同，因此我们没有指定要将副本添加到哪个主服务器。在这种情况下，redis-cli 会在副本较少的主节点中添加新节点作为随机主节点的副本。

但是，您可以使用以下命令行准确指定要使用新副本定位的主服务器：

```
redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```

通过这种方式，我们将新副本分配给特定的主节点。

将副本添加到特定主节点的更手动方法是将新节点添加为空主节点，然后使用[CLUSTER REPLICATE](https://redis.io/commands/cluster-replicate)命令将其转换为副本 。如果节点是作为副本添加的，但您想将其作为不同主节点的副本移动，这也适用。

例如，为了添加节点 127.0.0.1:7005 的副本，该节点当前为 11423-16383 范围内的哈希槽提供服务，节点 ID 为 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e，我需要做的就是连接新节点添加为空主）并发送命令：

```
redis 127.0.0.1:7006> cluster replicate 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
```

就是这样。现在我们有了这组哈希槽的新副本，集群中的所有其他节点都已经知道了（需要几秒钟来更新它们的配置）。我们可以使用以下命令进行验证：

```
$ redis-cli -p 7000 cluster nodes | grep slave | grep 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
f093c80dde814da99c5cf72a7dd01590792b783b 127.0.0.1:7006 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617702 3 connected
2938205e12de373867bf38f1ca29d31d0ddb3e46 127.0.0.1:7002 slave 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e 0 1385543617198 3 connected
```

节点 3c3a0c... 现在有两个副本，在端口 7002（现有的）和 7006（新的）上运行。



## 删除节点

要删除副本节点，只需使用`del-node`redis-cli 命令：

```
redis-cli --cluster del-node 127.0.0.1:7000 `<node-id>`
```

第一个参数只是集群中的一个随机节点，第二个参数是要删除的节点的 ID。

您也可以以相同的方式删除主节点，**但是为了删除主节点，它必须为空**。如果主节点不为空，您需要在此之前将数据从它重新分片到所有其他主节点。

删除主节点的另一种方法是对其一个副本执行手动故障转移，并在节点变成新主节点的副本后删除该节点。显然，当您想减少集群中的实际主节点数量时，这无济于事，在这种情况下，需要重新分片。



## 副本迁移

在 Redis 集群中，只需使用以下命令，就可以随时重新配置副本以使用不同的主服务器进行复制：

```
CLUSTER REPLICATE <master-node-id>
```

但是，在一种特殊情况下，您希望副本从一个主服务器自动移动到另一个主服务器，而无需系统管理员的帮助。副本的自动重新配置称为*副本迁移*，可以提高 Redis 集群的可靠性。

注意：您可以在[Redis Cluster Specification 中](https://redis.io/topics/cluster-spec)阅读副本迁移的详细信息，这里我们仅提供一些有关总体思路以及您应该做什么才能从中受益的信息。

您可能希望在特定条件下让集群副本从一个主节点移动到另一个主节点的原因是，通常 Redis 集群的抗故障能力与附加到给定主节点的副本数量一样。

例如，如果主节点和它的副本同时失败，其中每个主节点都有一个副本的集群无法继续操作，这仅仅是因为没有其他实例拥有主节点所服务的哈希槽的副本。然而，虽然网络分裂可能同时隔离多个节点，但许多其他类型的故障，如单个节点本地的硬件或软件故障，是一类非常显着的故障，不太可能同时发生时间，所以有可能在你的集群中，每个主节点都有一个副本，副本在凌晨 4 点被杀死，而主节点在早上 6 点被杀死。这仍然会导致集群无法再运行。

为了提高系统的可靠性，我们可以选择向每个主服务器添加额外的副本，但这很昂贵。副本迁移允许向少数主服务器添加更多副本。因此，您有 10 个 master，每个 master 有 1 个副本，总共有 20 个实例。但是，例如，您添加了 3 个以上的实例作为某些 master 的副本，因此某些 master 将拥有多个副本。

对于副本迁移，如果一个 master 没有副本，那么来自具有多个副本的 master 的副本将迁移到*孤立的*master。所以当你的副本在我们上面的例子中在凌晨 4 点宕机后，另一个副本将取代它，当主节点在凌晨 5 点也失败时，仍然可以选择一个副本，以便集群可以继续操作。

那么，简而言之，您应该了解的关于副本迁移的知识是什么？

- 集群将尝试从在给定时刻拥有最多副本的主节点迁移副本。
- 要从副本迁移中受益，您只需向集群中的单个主服务器添加更多副本，无论哪个主服务器都无关紧要。
- 有一个配置参数控制副本迁移功能，称为`cluster-migration-barrier`：您可以在`redis.conf`Redis Cluster 提供的示例文件中阅读有关它的更多信息。



## 升级Redis集群中的节点

升级副本节点很容易，因为您只需要停止节点并使用更新版本的 Redis 重新启动它。如果有客户端使用副本节点扩展读取，如果给定的副本不可用，它们应该能够重新连接到不同的副本。

升级masters有点复杂，建议的程序是：

1. 使用[CLUSTER FAILOVER](https://redis.io/commands/cluster-failover)触发主服务器到其副本之一的手动故障转移。（请参阅本文档中的[手动故障转移](https://redis.io/topics/cluster-tutorial#manual-failover)部分。）
2. 等待master变成副本。
3. 最后像复制副本一样升级节点。
4. 如果您希望主节点成为您刚刚升级的节点，请触发新的手动故障转移，以便将升级后的节点恢复为主节点。

按照此过程，您应该一个接一个地升级一个节点，直到所有节点都升级完毕。



## 迁移到 Redis 集群

愿意迁移到 Redis 集群的用户可能只有一个主节点，或者可能已经使用了预先存在的分片设置，其中使用一些内部算法或由他们的客户端库或 Redis 代理实现的分片算法在 N 个节点之间拆分密钥。

在这两种情况下，都可以轻松迁移到 Redis Cluster，但最重要的细节是应用程序是否使用多键操作，以及如何使用。有三种不同的情况：

1. 不使用多键操作，或事务，或涉及多键的 Lua 脚本。键是独立访问的（即使通过事务或 Lua 脚本将多个命令分组，大约相同的键，一起访问）。
2. 使用多键操作、事务或涉及多个键的 Lua 脚本，但仅使用具有相同**哈希标签**的键，这意味着一起使用的键都有一个`{...}`恰好相同的子字符串。例如，在同一个哈希标签的上下文中定义了以下多键操作：`SUNION {user:1000}.foo {user:1000}.bar`.
3. 多键操作、事务或涉及多个键的 Lua 脚本与没有显式或相同散列标签的键名一起使用。

第三种情况是Redis Cluster不处理的：应用需要修改才能不使用多键操作或者只在同一个hash标签的上下文中使用。

案例 1 和案例 2 已涵盖，因此我们将重点介绍以相同方式处理的这两个案例，因此文档中将不做区分。

假设您将预先存在的数据集拆分为 N 个主节点，其中 N=1 如果您没有预先存在的分片，则需要执行以下步骤才能将数据集迁移到 Redis 集群：

1. 停止你的客户。目前无法自动实时迁移到 Redis 集群。您可以在您的应用程序/环境的上下文中编排实时迁移。
2. 使用 BGREWRITEAOF 命令为所有 N 个母版生成一个 append only 文件，并等待 AOF 文件完全生成。
3. 将您的 AOF 文件从 aof-1 保存到 aof-N 某处。此时，您可以根据需要停止旧实例（这很有用，因为在非虚拟化部署中您经常需要重复使用相同的计算机）。
4. 创建一个由 N 个 master 和 0 个副本组成的 Redis Cluster。稍后您将添加副本。确保您的所有节点都使用仅附加文件进行持久化。
5. 停止所有集群节点，将它们的仅附加文件替换为您预先存在的仅附加文件，第一个节点为 aof-1，第二个节点为 aof-2，最多为 aof-N。
6. 使用新的 AOF 文件重新启动 Redis 集群节点。他们会抱怨说，根据他们的配置，有些密钥不应该存在。
7. 使用`redis-cli --cluster fix`命令来修复集群，以便根据每个节点是否具有权威性的哈希槽来迁移密钥。
8. 最后使用`redis-cli --cluster check`以确保您的集群正常。
9. 重新启动修改为使用 Redis 集群感知客户端库的客户端。

有另一种方法可以将数据从外部实例导入到 Redis 集群，即使用`redis-cli --cluster import`命令。

该命令将正在运行的实例的所有键（从源实例中删除键）移动到指定的预先存在的 Redis 集群。但是请注意，如果您使用 Redis 2.8 实例作为源实例，操作可能会很慢，因为 2.8 没有实现迁移连接缓存，因此您可能希望在执行此类操作之前使用 Redis 3.x 版本重新启动源实例。

**关于本页使用的 slave 一词的注意事项**：从 Redis 5 开始，如果不是为了向后兼容，Redis 项目不再使用 slave 一词。不幸的是，在这个命令中，slave 这个词是协议的一部分，所以只有当这个 API 自然被弃用时，我们才能删除此类事件。